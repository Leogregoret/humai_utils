# -*- coding: utf-8 -*-
"""docker-conceptos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/docker-conceptos.ipynb

# Conceptos Docker

![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/logo-scaled.png?raw=1)

## El camino del desarrollador
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/jedi.png?raw=1)  
- "Rescatamos" alg칰n proyecto previo.
- Instalamos **dependencias** que vamos necesitando.
- Configuramos **variables de entorno**.
- Agregamos archivos de configuraci칩n.
- Incorporamos **assets**: img, css, js.
- Resolvemos el problema.
- Y un dia lo tenemos que subir a la **nube**  

## Proyectos en distintas plataformas
### Proyecto Node.js
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/node-project.png?raw=1)
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/package.json.png?raw=1)
```bash
npm install
npm run start
```

### Proyecto Java
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/java-project.png?raw=1)
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/pom.xml.png?raw=1)
```bash
mvn pom.xml
java -jar MyApplication.jar
```

### Proyecto Python
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/python-project.png?raw=1)
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/requirements.txt.png?raw=1)  
```bash
pip install -r requirements.txt
python app.py
```

### Otras plataformas
- Proyectos .NET, PHP, Ruby, Go, etc. son similares.
- Nuestras aplicaciones adem치s necesitan otros servidores y bases de datos para funcionar  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/otras-plataformas.png?raw=1)

## Previamente para llegar a la nube
- Probamos que todo funcione bien en forma local.
- Zipeamos el c칩digo fuente.
- Instanciamos una m치quina en EC2 o en Compute Engine.
- Subimos el c칩digo.
- Instalamos las dependencias.
- Rezamos para que no nos hayamos olvidado nada 游똂
- Corremos nuestro proyecto.

- 쯏 si no funciona?  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/it-works.jpg?raw=1)
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/ship.png?raw=1)
- Este enfoque puede funcionar bien para deployar una vez.
- 쯉i tenemos que replicar nuestra aplicaci칩n muchas veces?
- 쯏 si nos peleamos con el problema antes de subir a la nube?
- 쯏 si construimos el ambiente que necesita nuestra aplicaci칩n una sola vez?
- Esta es la propuesta de los containers.
- Llevar este ambiente de un entorno a otro, de local a producci칩n.

## Docker
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/200.png?raw=1)
- Nuestra ballena preferida al rescate: Docker
- Docker permite que una m치quina de base pueda compartir tiempo de CPU, Memoria y Disco con peque침as m치quinas llamados containers.
- Es mucho m치s 칩ptimo que la Virtualizaci칩n cl치sica porque no levanta un Sistema Operativo completo.
- Provee una forma de ejecutar software de forma segura, en un entorno aislado, empaquetado y con todas sus dependencias y librer칤as.

## Virtualizaci칩n vs Docker
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/virtualizacion.png?raw=1)

## Propiedades de los contenedores
- Un contenedor es un proceso **autocontenido**.
- Se lanza a partir de una **imagen**.
- Esta imagen tiene **todo lo necesario** para que el contenedor pueda correr.
- No es necesario crear esta imagen a partir de un OS completo.
- Por lo tanto es mucho **m치s liviano** que una VM.
- Todos los contenedores son **independientes** entre s칤 y del entorno en el que corren.
- Permite **aprovechar mucho mejor** los recursos de hardware del host.

## Arquitectura de Docker
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/engine.png?raw=1)  
https://docs.docker.com/get-started/overview/

## Docker Engine y Docker CLI
- Instalar Docker Community Edition (CE) https://docs.docker.com/install/
- Cliente / Servidor: Docker CLI / Docker Engine
- En Linux corre de forma nativa y comparte el kernel con sus containers.
- En Windows corre a trav칠s de Hyper-V.
- En Mac corre a trav칠s HyperKit.
- Previamente se corr칤a mediante VirtualBox (Docker Toolbox).

## Imagenes y contenedores
- Comparemos c칩mo se crean un proceso regular y un contenedor de Docker.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/process.png?raw=1)  
- Un proceso regular del Sistema operativo se inicia a partir de un ejecutable (.exe), el cual fue compilado a partir de un c칩digo fuente. Similar para lenguajes interpretados.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/exe.png?raw=1)  
- Para el caso de un contenedor, al c칩digo se le suman las dependencias, variables de entorno, archivos de configuraci칩n, etc. y crean un Dockerfile. El Dockerfile es una lista de instrucciones que le pasamos al Docker Engine para que construya la imagen.   
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/runtime.png?raw=1)  
- Con el comando `docker build` le pasamos el Dockerfile al Docker Engine, que sigue las instrucciones para crear una Imagen de Docker que luego se usa para iniciar un contenedor. Un contenedor se construye a partir de un molde, este molde se conoce como imagen.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/image.png?raw=1)  
- Con la Imagen de Docker iniciamos un contenedor con `docker run`  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/docker-run.png?raw=1)  
- El nuevo contenedor va a correr junto a los dem치s contenedores que tenga dentro de mi Docker Engine. Los contenedores est치n aislados los unos de los otros: Docker Engine regula cu치ntos recursos asigna a cada uno. Cada vez que corremos docker build creamos una imagen nueva.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/containers.png?raw=1)  
- Podemos correr una imagen de Docker como un contenedor en otro sistema. Docker nos asegura que este nuevo contenedor va a correr como el original.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/other-engine.png?raw=1)  
- Esta portabilidad permite resolver el problema de compatibilidad entre sistemas que tendr칤amos si quisi칠ramos correr el proceso directamente en otro sistema.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/not-exe.png?raw=1)

## Corramos un container!

## Arquitectura de Docker
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/main-comands.png?raw=1)  
https://docs.docker.com/get-started/overview/

## Construcci칩n de una imagen
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/construccion-imagen.png?raw=1)  
- Un contenedor se lanza a partir de un molde que se conoce como **imagen**.
- Cuando construimos la imagen, cada comando que vamos ejecutando genera un **cambio** en el sistema de archivos de la misma.
- Estos cambios se llaman **capas**, por lo tanto una imagen de Docker es el resultados de todas las capas que se fueron apilando en el pasado con estos cambios.
- Se dice asi que cada capa **hereda** de la capa anterior.
- Las im치genes de Docker son **inmutables**.
- Las capas intermedias que se generan durante la construccion de una imnagen son **cacheadas** para un uso posterior y para agilizar el proceso de construccion.
- Docker cuenta con una serie de **comandos** especifica para la construcci칩n de imagenes.
- Las instrucciones de construccion se agrupan en un archivo llamado por convencion `Dockerfile`
- Estas instrucciones son ejecutadas al invocar el comando `docker build`
- Para la construcci칩n de im치genes es necesario el archivo `Dockerfile` y un **contexto de construcci칩n**.
- Basicamente consiste en los **archivos** que vamos a incorporar a la imagen de Docker, suelen ser el codigo y las dependencias.
- El contexto de construcci칩n es una **carpeta local** o un **repositorio** de git.

## Construyamos una imagen!

## Persistencia
- Todo contenedor tiene asociado un **sistema de archivos** basado en el sistema operativo desde el que se construy칩 la imagen.
- Este sistema de archivos vive en **memoria** (es r치pido!) y todo cambio que hagamos durante la ejecuci칩n se guarda en una capa escribible del contenedor.
- Est치 fuertemente **acoplado** al contenedor que lo usa.
- Cuando el contenedor termina ya vimos que va a parar a alg칰n lugar del disco del host.
- Es posible "resucitar" un contenedor terminado y recuperar sus archivos, pero no es lo m치s 칩ptimo.
- Si eliminamos el contenedor, nuestros datos se van con 칠l.

## Opciones de Storage
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/storage.png?raw=1)  
https://docs.docker.com/storage/

### Volumenes
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/volumenes.png?raw=1)
- La m치quina host le cede **una parte** del disco que administra el Docker Engine (/var/lib/docker/volumes/ en Linux)
- Procesos que no sean los de Docker **no deber칤an escribir** nada en esa parte. Es propiedad del root.
- Se pueden crear con o sin un contenedor que los use.
- Se pueden montar en **varios** contenedores.
- El container lo "ve" como un directorio m치s, es transparente.
- Pueden ser **nombrados** o **an칩nimos**.
- Se borran solo cuando lo hacemos **expl칤citamente**
- Si tuvieramos la necesidad de llevar nuestro container a la nube o a otro host nos podriamos llevar este directorio de volumenes a otro host.
- https://docs.docker.com/storage/volumes/

### Puntos de Montaje
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/bind-amount.png?raw=1)
- Pueden ser **cualquier parte** del disco del host.
- El host le hace visible una parte de su sistema de archivos a un contenedor (cuidado! `/root`).
- Procesos que no sean los de Docker **pueden escribir** en el punto de montaje.
- El contenedor tambi칠n lo "ve" como un directorio m치s.
- Fuertemente acoplados a que la **ruta exista** en el host que corre el contenedor.
- No son tan flexibles como los volumenes y en general se desaconseja su uso.
- Se usan para compartir configuraci칩n con el contenedor, por ejemplo resoluci칩n de DNS (/etc/resolv.conf)
- Si estamos haciendo alg칰n desarrollo y queremos reflejar un cambio en el c칩digo **instant치neamente** en el contenedor, le podriamos montar nuestra carpeta de archivos compilados o binarios.
- https://docs.docker.com/storage/bind-mounts/

### tmpfs mounts
- Solo existen en memoria y nunca se escriben a disco.
- Ideal para cach칠 o archivos sensibles.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/tmpfs.png?raw=1)  

### 쮺omo se usan?
- Creacion, listado y manipulaci칩n de volumenes: `docker volume`
- Montaje a la hora de arrancar un contenedor se hace con el par치metro `-v` o `--volume`
- Iniciar con un contenedor con `--tmpfs /app`

## Usemos Volumes & Bind Mounts!

## Docker Compose
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/alone.png?raw=1)  
- Ning칰n contenedor anda solo por la vida.
- Docker Compose nos permite correr m칰ltiples contenedores (probablemente de la misma aplicaci칩n) en el **mismo Docker Engine**.
- Los contenedores se configuran en archivos YAML como `services`.
- Con un solo comando podemos levantar y administrar **todos** estos servicios.
- Cada servicio puede ser una imagen de Docker local (basada en un Dockerfile) o remota (DockerHub o cualquier otro Docker Registry).
- Ideal para testear una aplicaci칩n completa en nuestra m치quina antes de trasladarla a la nube y probarla con varias configuraciones distintas: local, stage, production.
- Docker Compose crea una red interna entre todos estos servicios para que se vean entre si.
- Los atributos de cada service tienen su correspondiente en el docker run: Puertos, Variables de entorno, Volumenes.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/pulpo.png?raw=1)  

## Usemos Docker Compose!
"""