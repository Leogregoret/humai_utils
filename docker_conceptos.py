# -*- coding: utf-8 -*-
"""docker-conceptos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/docker-conceptos.ipynb

# Conceptos Docker

![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/logo-scaled.png?raw=1)

## El camino del desarrollador
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/jedi.png?raw=1)  
- "Rescatamos" algún proyecto previo.
- Instalamos **dependencias** que vamos necesitando.
- Configuramos **variables de entorno**.
- Agregamos archivos de configuración.
- Incorporamos **assets**: img, css, js.
- Resolvemos el problema.
- Y un dia lo tenemos que subir a la **nube**  

## Proyectos en distintas plataformas
### Proyecto Node.js
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/node-project.png?raw=1)
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/package.json.png?raw=1)
```bash
npm install
npm run start
```

### Proyecto Java
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/java-project.png?raw=1)
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/pom.xml.png?raw=1)
```bash
mvn pom.xml
java -jar MyApplication.jar
```

### Proyecto Python
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/python-project.png?raw=1)
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/requirements.txt.png?raw=1)  
```bash
pip install -r requirements.txt
python app.py
```

### Otras plataformas
- Proyectos .NET, PHP, Ruby, Go, etc. son similares.
- Nuestras aplicaciones además necesitan otros servidores y bases de datos para funcionar  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/otras-plataformas.png?raw=1)

## Previamente para llegar a la nube
- Probamos que todo funcione bien en forma local.
- Zipeamos el código fuente.
- Instanciamos una máquina en EC2 o en Compute Engine.
- Subimos el código.
- Instalamos las dependencias.
- Rezamos para que no nos hayamos olvidado nada 🙏
- Corremos nuestro proyecto.

- ¿Y si no funciona?  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/it-works.jpg?raw=1)
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/ship.png?raw=1)
- Este enfoque puede funcionar bien para deployar una vez.
- ¿Si tenemos que replicar nuestra aplicación muchas veces?
- ¿Y si nos peleamos con el problema antes de subir a la nube?
- ¿Y si construimos el ambiente que necesita nuestra aplicación una sola vez?
- Esta es la propuesta de los containers.
- Llevar este ambiente de un entorno a otro, de local a producción.

## Docker
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/200.png?raw=1)
- Nuestra ballena preferida al rescate: Docker
- Docker permite que una máquina de base pueda compartir tiempo de CPU, Memoria y Disco con pequeñas máquinas llamados containers.
- Es mucho más óptimo que la Virtualización clásica porque no levanta un Sistema Operativo completo.
- Provee una forma de ejecutar software de forma segura, en un entorno aislado, empaquetado y con todas sus dependencias y librerías.

## Virtualización vs Docker
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/virtualizacion.png?raw=1)

## Propiedades de los contenedores
- Un contenedor es un proceso **autocontenido**.
- Se lanza a partir de una **imagen**.
- Esta imagen tiene **todo lo necesario** para que el contenedor pueda correr.
- No es necesario crear esta imagen a partir de un OS completo.
- Por lo tanto es mucho **más liviano** que una VM.
- Todos los contenedores son **independientes** entre sí y del entorno en el que corren.
- Permite **aprovechar mucho mejor** los recursos de hardware del host.

## Arquitectura de Docker
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/engine.png?raw=1)  
https://docs.docker.com/get-started/overview/

## Docker Engine y Docker CLI
- Instalar Docker Community Edition (CE) https://docs.docker.com/install/
- Cliente / Servidor: Docker CLI / Docker Engine
- En Linux corre de forma nativa y comparte el kernel con sus containers.
- En Windows corre a través de Hyper-V.
- En Mac corre a través HyperKit.
- Previamente se corría mediante VirtualBox (Docker Toolbox).

## Imagenes y contenedores
- Comparemos cómo se crean un proceso regular y un contenedor de Docker.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/process.png?raw=1)  
- Un proceso regular del Sistema operativo se inicia a partir de un ejecutable (.exe), el cual fue compilado a partir de un código fuente. Similar para lenguajes interpretados.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/exe.png?raw=1)  
- Para el caso de un contenedor, al código se le suman las dependencias, variables de entorno, archivos de configuración, etc. y crean un Dockerfile. El Dockerfile es una lista de instrucciones que le pasamos al Docker Engine para que construya la imagen.   
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/runtime.png?raw=1)  
- Con el comando `docker build` le pasamos el Dockerfile al Docker Engine, que sigue las instrucciones para crear una Imagen de Docker que luego se usa para iniciar un contenedor. Un contenedor se construye a partir de un molde, este molde se conoce como imagen.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/image.png?raw=1)  
- Con la Imagen de Docker iniciamos un contenedor con `docker run`  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/docker-run.png?raw=1)  
- El nuevo contenedor va a correr junto a los demás contenedores que tenga dentro de mi Docker Engine. Los contenedores están aislados los unos de los otros: Docker Engine regula cuántos recursos asigna a cada uno. Cada vez que corremos docker build creamos una imagen nueva.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/containers.png?raw=1)  
- Podemos correr una imagen de Docker como un contenedor en otro sistema. Docker nos asegura que este nuevo contenedor va a correr como el original.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/other-engine.png?raw=1)  
- Esta portabilidad permite resolver el problema de compatibilidad entre sistemas que tendríamos si quisiéramos correr el proceso directamente en otro sistema.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/not-exe.png?raw=1)

## Corramos un container!

## Arquitectura de Docker
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/main-comands.png?raw=1)  
https://docs.docker.com/get-started/overview/

## Construcción de una imagen
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/construccion-imagen.png?raw=1)  
- Un contenedor se lanza a partir de un molde que se conoce como **imagen**.
- Cuando construimos la imagen, cada comando que vamos ejecutando genera un **cambio** en el sistema de archivos de la misma.
- Estos cambios se llaman **capas**, por lo tanto una imagen de Docker es el resultados de todas las capas que se fueron apilando en el pasado con estos cambios.
- Se dice asi que cada capa **hereda** de la capa anterior.
- Las imágenes de Docker son **inmutables**.
- Las capas intermedias que se generan durante la construccion de una imnagen son **cacheadas** para un uso posterior y para agilizar el proceso de construccion.
- Docker cuenta con una serie de **comandos** especifica para la construcción de imagenes.
- Las instrucciones de construccion se agrupan en un archivo llamado por convencion `Dockerfile`
- Estas instrucciones son ejecutadas al invocar el comando `docker build`
- Para la construcción de imágenes es necesario el archivo `Dockerfile` y un **contexto de construcción**.
- Basicamente consiste en los **archivos** que vamos a incorporar a la imagen de Docker, suelen ser el codigo y las dependencias.
- El contexto de construcción es una **carpeta local** o un **repositorio** de git.

## Construyamos una imagen!

## Persistencia
- Todo contenedor tiene asociado un **sistema de archivos** basado en el sistema operativo desde el que se construyó la imagen.
- Este sistema de archivos vive en **memoria** (es rápido!) y todo cambio que hagamos durante la ejecución se guarda en una capa escribible del contenedor.
- Está fuertemente **acoplado** al contenedor que lo usa.
- Cuando el contenedor termina ya vimos que va a parar a algún lugar del disco del host.
- Es posible "resucitar" un contenedor terminado y recuperar sus archivos, pero no es lo más óptimo.
- Si eliminamos el contenedor, nuestros datos se van con él.

## Opciones de Storage
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/storage.png?raw=1)  
https://docs.docker.com/storage/

### Volumenes
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/volumenes.png?raw=1)
- La máquina host le cede **una parte** del disco que administra el Docker Engine (/var/lib/docker/volumes/ en Linux)
- Procesos que no sean los de Docker **no deberían escribir** nada en esa parte. Es propiedad del root.
- Se pueden crear con o sin un contenedor que los use.
- Se pueden montar en **varios** contenedores.
- El container lo "ve" como un directorio más, es transparente.
- Pueden ser **nombrados** o **anónimos**.
- Se borran solo cuando lo hacemos **explícitamente**
- Si tuvieramos la necesidad de llevar nuestro container a la nube o a otro host nos podriamos llevar este directorio de volumenes a otro host.
- https://docs.docker.com/storage/volumes/

### Puntos de Montaje
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/bind-amount.png?raw=1)
- Pueden ser **cualquier parte** del disco del host.
- El host le hace visible una parte de su sistema de archivos a un contenedor (cuidado! `/root`).
- Procesos que no sean los de Docker **pueden escribir** en el punto de montaje.
- El contenedor también lo "ve" como un directorio más.
- Fuertemente acoplados a que la **ruta exista** en el host que corre el contenedor.
- No son tan flexibles como los volumenes y en general se desaconseja su uso.
- Se usan para compartir configuración con el contenedor, por ejemplo resolución de DNS (/etc/resolv.conf)
- Si estamos haciendo algún desarrollo y queremos reflejar un cambio en el código **instantáneamente** en el contenedor, le podriamos montar nuestra carpeta de archivos compilados o binarios.
- https://docs.docker.com/storage/bind-mounts/

### tmpfs mounts
- Solo existen en memoria y nunca se escriben a disco.
- Ideal para caché o archivos sensibles.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/tmpfs.png?raw=1)  

### ¿Como se usan?
- Creacion, listado y manipulación de volumenes: `docker volume`
- Montaje a la hora de arrancar un contenedor se hace con el parámetro `-v` o `--volume`
- Iniciar con un contenedor con `--tmpfs /app`

## Usemos Volumes & Bind Mounts!

## Docker Compose
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/alone.png?raw=1)  
- Ningún contenedor anda solo por la vida.
- Docker Compose nos permite correr múltiples contenedores (probablemente de la misma aplicación) en el **mismo Docker Engine**.
- Los contenedores se configuran en archivos YAML como `services`.
- Con un solo comando podemos levantar y administrar **todos** estos servicios.
- Cada servicio puede ser una imagen de Docker local (basada en un Dockerfile) o remota (DockerHub o cualquier otro Docker Registry).
- Ideal para testear una aplicación completa en nuestra máquina antes de trasladarla a la nube y probarla con varias configuraciones distintas: local, stage, production.
- Docker Compose crea una red interna entre todos estos servicios para que se vean entre si.
- Los atributos de cada service tienen su correspondiente en el docker run: Puertos, Variables de entorno, Volumenes.  
![](https://github.com/institutohumai/cursos-python/blob/master/PracticasDeDesarrollo/4_Desarrollo_IV/docker-conceptos/images/pulpo.png?raw=1)  

## Usemos Docker Compose!
"""